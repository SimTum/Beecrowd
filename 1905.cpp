#include <iostream>
using namespace std;

struct Grid // Структура сетка
{
public:
    int val = 0;       // Это значение которое содержится в данной ячейке. 0 - дорога, 1 - стена, 2 - пункт назначения
    Grid *left = NULL; // Это указатели на соседние клетки. По умолчанию Они указывают в никуда (NULL)
    Grid *right = NULL;
    Grid *above = NULL;
    Grid *below = NULL;
    bool checked = 0; // Это логическая переменная для функции по поиску маршрута. 0 - значит что эта ячейка ещё не проверялась. 1 - уже проверялась и алгоритм запускать не надо
};

void pathfinder(Grid *start, bool *path) // функция по поиску маршрута. Вернись сюда после того как прочитаешь  что делает main(). В эту функции мы задаём адрес начальной клетик (Grid *start) и адрес переменной проверки, хранящийся вне функции (bool *path). В кратце - эта функия проверит ВСЕ доступные маршруты, и если она найдёт маршрут к желаемой цели, она вернёт единицу (COPS) и если нет, то ничего не изменится и ответ останется равен 0 (ROBBERS)
{
    if (start->val == 2) // если значение ячейки равно 2, то мы нашли путь и переменная path принимает значение 1
        *path = 1;
    start->checked = 1;                                                   // отмечаем что мы проверили жту клетку, чтобы функия поиска не вызывалась бесконечно
    if (start->right && start->right->val != 1 && !start->right->checked) // Тут, функиця если проверяет 3 вещи: Если есть сосеlние клетки, если их значение не равно 1 (стена) и если мы уже проверяли эту клетку. Если клетка есть, в ней нет стены, и мы её не проверяли, мы вызываем эту же функцию, только уже с новой клеткой как точкой старта
    {
        pathfinder(start->right, path);
    }
    if (start->below && start->below->val != 1 && !start->below->checked)
        pathfinder(start->below, path);
    if (start->left && start->left->val != 1 && !start->left->checked)
        pathfinder(start->left, path);
    if (start->above && start->above->val != 1 && !start->above->checked)
        pathfinder(start->above, path);
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int cases; // задаём количество тестовых кейсов
    cin >> cases;
    int grid[5][5]; // задаём сетку  целых чисел (матрица 5 на 5 в этой задаче)
    // cout << "wtf \n";
    Grid *cell[5][5]; // задаём сетку адрессов ячеей нашей структуры Grid
    for (int i = 0; i < cases; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            for (int k = 0; k < 5; k++)
            {
                cin >> grid[j][k];            // Заполняе матрицу
                cell[j][k] = new Grid();      // для каждой клетки матрицы инициализируем новую ячейку в сетке
                cell[j][k]->val = grid[j][k]; // Заполняем ячейки в сетке значениями соответствующим значениям в матрице
                // cout << grid[j][k] << " ";
            }
            // cout << "\n";
        }
        for (int j = 0; j < 5; j++)
        {
            for (int k = 0; k < 5; k++) // В этом цикле обозначаем соседий каждой клетки, учитывая фатк что у крайней угловых клеток может быть только 2 соседа
            {
                // cout << cell[j][k]->val << " ";
                if (k > 0)
                    cell[j][k]->left = cell[j][k - 1]; // Например зздесь, левый сосед может быть только у клеток с 0-го по 3-й ряд. Так как у 4-го ряда соседей слева уже не будет
                if (k < 4)
                    cell[j][k]->right = cell[j][k + 1];
                if (j > 0)
                    cell[j][k]->above = cell[j - 1][k];
                if (j < 4)
                    cell[j][k]->below = cell[j + 1][k];
            }
            // cout << "\n";
        }

        if (cell[4][4]->val == 0) // проверяем если в нижней правой сетке стоит 0. Если да, то заменяем его на 2 (наша цель всегда нижний правый угол)
            cell[4][4]->val = 2;
        // cout << cell[4][4]->val;
        string answer;
        bool path = 0;
        if (cell[0][0]->val == 1) // проверяемм если верхняя левая клетка (начало) заблокированно. Если да, то пути нет, и ответом будет ROBBERS
            answer = "ROBBERS";
        else
        {
            pathfinder(cell[0][0], &path); //запускаем функцию void pathfinder которая была выше. Если путь найден, ответ равен COPS,Ы если нет, то ROBBERS
            if (path)
                answer = "COPS";
            else
                answer = "ROBBERS";
        }
        cout << answer << "\n";
    }
    return 0;
}